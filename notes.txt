Check out tcl, pike, lua, c, lpc, perl6, ruby, python

Try to take out # statements from lpc
Try to add comments as optional strings to the language
        Make comments part of the language for descriptions of things
        Also still need a way to disable blocks of code...

tcl is like scheme...  Need to figure out other common commands even
        if they are redefine-able...
        Perl is similar in some ways?

TCL bnf:
        program ::= {statement}+
        statement ::= command {arg}*

look at vim folding...

I'm thinking editor needs to parse code to do things like hide/fold comments
why muck with re-indenting code all the time, better to make editor
do this job, and a pretty printer of a certain width...  In code though
save it as one specific pretty print.
Compiler should pretty print code, how do you deal with comments that
        are table like?  Comments must respect whitespace (\n,\t,space)


tcl built-in commands:
        control structures: if, for, foreach, switch
        string manipulation functions regex, strlen, etc...
        IO (disk, network, devices):
                File management: file names, reading writing, copying,
                        deleting, mkdir
        Lists
        Arrays
        time and date manipulation
        events....

        Also look at:
        http://docs.activestate.com/activetcl/8.4/tcl/tcl_2_contents.htm


New lpc
Look at:
http://mud.stack.nl/manuals/lpc_toc.html
and 
http://rigaux.org/language-study/syntax-across-languages.html

remove preprocessor stuff...
        #include becomes include '';
no optional {}'s  they are required.
No assignment during declarations.
if () {} else if {} else {}    # And or simpler versions...
for (;;) {} becomes for (,,) {}   # ,'s are used to separate args
while () {}                       # No do while.... 
foreach i () { }     
Comments #  or strings when declaring vars or functions...
        Note no // or /* */ supported...
	# I don't like looking at php code because there are so many
	# ways to do comments, lets reduce complexity...

switch (var) {			# Use { } for blocks just like everywhere else.
   case thing { }		# This makes it so you can't do certain things
   case thing2 { }		# But it makes the user sure of what's going on.
   else { }			# Already have else so don't introduce default.
}

variable def:
   int x;
   int x "The value";
   int *x "An array of the values we are " +
      "going to use";

types: void, int, float, string, object, mapping, mixed;

function definition:
returntype name "Description" (vartype varname "Description" [,...]) { }

Add support to vim, geany, eclipse, netbeans

Look at go's fixit   make something similar that is --upgrade

Eventually make it so can build our compiler/thing from 
	both c or newlang...
	Maybe have advanced things like critic newlang only?

Need to support built in unit testing as part of the language.
optional but warn if not defined.  I'm thinking something like
if you have a function
int myfunction() { }
should have a 
	int test_myfunction() { }
	as well, which will test the function.
	Probably a bit more advanced than that but thats a good place to start.

config file is one of our objects.
have the following search path for our config file:
	CURRENTWORKING DIR/.(language)rc (Maybe allow disabling this)
	USERS HOMEDIR/.(language)rc (Again maybe allow disabling this)
	INSTALLDIR/etc/.(language)rc

Have the notion of working directory.  Set it to . by default but
can be specified on commandline or through config.  The idea being that
you can't reference files outside of the working dir.  (Note: you'll
still be able to inherit installed inheritables and include installed
include files)

entry function for our objects is create(); (Not main);

Need to avoid the Must create a creator/destructor for every class.
In lpc this is we need to not have to create a
query_XXXX();  set_XXXX(VAR); for everything... would be nice if
this were already made for each builtin type.
	see lib/std/object.sw

Try to reduce other common things in code...

inline comments in the code look ugly in standard code lets look at options to
try and clean it up so its nice looking in regular text as well.

Look at doxigen for other languages and see if we can add support for what
we are doing.  Can we leverage perl pod?  Should we?  Try it and see...

Need to figure out how to do varargs....

have a way to set workingdir...
	maybe have sensable defaults like:
		workingdir/lib
		workingdir/include
		workingdir/data

check out rubyspec
	Very good idea, test system for your language that evolves with
	the language.
