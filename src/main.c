/*** Compiler Front-End Test automatically generated by the BNF Converter ***/
/*                                                                          */
/* This test will parse a file, print the abstract syntax tree, and then    */
/* pretty-print the result.                                                 */
/*                                                                          */
/****************************************************************************/
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

#include "Parser.h"
#include "Printer.h"
#include "Absyn.h"

#define VERSION "0.0"

int print = -1;
int help = -1;
int critic = -1;
int libdir = -1;
int incdir = -1;
int output = -1;
int version = -1;
int test = -1;
int upgrade = -1;
int opt = 0;


static struct option long_options[] = {
	{"print",	no_argument,		0,	'p' },
	{"help",	no_argument,		0,	'h' },
	{"critic",	no_argument,		0,	'c' },
	{"include",	required_argument,	NULL,	'I' },
	{"lib",		required_argument,	NULL,	'L' },
	{"output",	required_argument,	NULL,	'o' },
	{"upgrade",	no_argument,		NULL,	'u' },
	{"version",	no_argument,		NULL,	'v' },
	{"test",	no_argument,		NULL,	't' },
	{0,		0,			0,	0 }
};

int print_version(char *name) {
	printf("%s Version: %s\n", name, VERSION);
/*
	printf("%s_config_path: %s\n", name, config_path);
	printf("%s_config_file: %s\n", name, config_file);
	printf("%s_critic_path: %s\n", name, critic_path);
	printf("%s_include_path: %s\n", name, include_path);
	printf("%s_lib_path: %S\n", name, lib_path);

	printf("Found inheritables:\n");
	XXX
*/
	return 1;
}

int print_usage(char *name) {
	printf("Usage: %s [OPTIONS] [INFILE]\n", name);
	printf("\tEvaluate the file INFILE.  If no file is given, read ");
	printf("from stdin.\n");
	printf("Available Options:\n");
	printf("\t-c --critic\n\t\tPrint feedback on the submitted code.\n");
	printf("\t-h --help\n\t\tThis usage information.\n");
	printf("\t-I --include=DIR\n\t\tSpecify a directory to search for ");
	printf("include files.\n");
	printf("\t-L --lib=DIR\n\t\tSpecify a directory to search for ");
	printf("inheritables.\n");
	printf("\t-o --output=FILE\n\t\tSpecify a filename to compile ");
	printf("the code to.\n");
	printf("\t-p --print\n\t\tParse the file and then print it in the ");
	printf("standard format.\n");
	printf("\t-t --test\n\t\tRun all of the test_* functions in the code.");
	printf("\t-u --upgrade\n\t);
	printf("\tUpgrade the specified file to the current syntax.");
	printf("\t-v --version\n\t);
	printf("\tPrint Version and configuration information.\n");

	return 0;
}

int do_critic(char *outfile, Program parse_tree) {
	printf("Inside do_critic: XXX Needs to be implemented.\n");
	return 0;
}

int run_tests(char *outfile, Program parse_tree) {
	printf("Inside run_tests: XXX Needs to be implemented.\n");
	return 0;
}

int print_file(char *outfile, Program parse_tree) {
	FILE *ofile;

	if (output == 1) {
		ofile = fopen(outfile,"w");
		if (!ofile) {
			fprintf(stderr,"Unable to write to file: %s\n",
				outfile);
			return 0;
		}

		fprintf(ofile,"[Linearized Tree]\n");
		fprintf(ofile,"%s\n\n", printProgram(parse_tree));

		fclose(ofile);
	} else {
		printf("[Linearized Tree]\n");
		printf("%s\n\n", printProgram(parse_tree));
	}
	return 1;
}

int run_code(char *outfile, Program parse_tree) {
	printf("Inside run_code: XXX Needs to be implemented.\n");
	return 0;
}

int main(int argc, char ** argv) {
	FILE *input;
	char *outfile;
	Program parse_tree;
	int long_index = 0;

	while ((opt = getopt_long(argc, argv, "chptuvL:I:o:", long_options,
		&long_index)) != -1) {
		switch (opt) {
			case 'c':
				critic = 1;
				break;
			case 'L':
				break;
			case 'I':
				break;
			case 'o':
				output = 1;
				break;
			case 'p':
				print = 1;
				break;
			case 'u':
				upgrade =1;
				break;
			case 'v':
				version =1;
				break;
			case 't':
				test = 1;
				break;
			default:
				return print_usage(argv[0]);
		}
	}

	if (optind < argc) {
		input = fopen(argv[optind], "r");

		if (!input) {
			fprintf(stderr, "Error opening input file: %s\n",
				argv[optind]);
			exit(1);
		}
	} else {
		input = stdin;
	}

	if (version == 1) {
		return print_version(argv[0]);
	}

	if (upgrade == 1) {
		/* Need to upgrade our code XXX which is more complicated 
			version of parse_tree */
		parse_tree = pProgram(input);
		
	} else {
		parse_tree = pProgram(input);
	}

	if (parse_tree) {
		printf("\nParse Successful!\n");
		printf("\n[Abstract Syntax]\n");
		printf("%s\n\n", showProgram(parse_tree));

		if (print == 1) {
			return print_file(outfile, parse_tree);
		} else if (critic == 1) {
			return do_critic(outfile, parse_tree);
		} else if (test == 1) {
			run_tests(outfile, parse_tree);
		} else {
			run_code(outfile, parse_tree);
		}

		return 0;
	}

	return 1;
}

