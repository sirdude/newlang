=head1 Comments

Comments in a programming language are use for a number of reasons.
Many times they are used to explain a hairy piece of code, or to document
hidden features of a function, or to provide a summary of how a function works
in a higher level.  They are also used to disable certain blocks of code.

Many programs today support two types of comments, commenting out a line
or the end of a line, or commenting out a block of code.  The idea behind
our language is that comments that add value to a piece of code, a function,
variable, or code block will be a part of the syntax of the language.

This will hopefully eliminate the majority of comments in code.  We will
still support comments for blocking out code, and or adding comments to
other locations.  To keep this simple and hopefully avoid errors we are
choosing to only support single line comments with a #
So on a given line anything after a '#' and before a newline is considered
a comment.

=head1 Types
Types are used for variables and functions.  In the case of variables, they 
are used by the language to reserve space for a variable, and define how the
language works with that variable.  In general a string takes up
more space than an integer.  If I have a statement x + y;  It will more than
likely behave differently if our variables are strings or integers.

For functions types are used to define what the return value(s) of a 
function will look like.

=head2 Basic Types
Our programming language supports the following basic types:
=item void
=item int
=item float
=item string
=item object
=item mapping
=item mixed

=head2 Arrays
In addition to basic types you can also create an array out of any of the
basic types.  To define an array prepend the variable name with a *.
	int x;
Becomes:
	int *x;

It's ok to mix regular types and arrays in declarations:
	int x, *y, z;	# Declares two int''s x,z and an array of ints y

=head2 Type Modifiers
Our programming language supports the following type modifiers:
=item nomask
=item static
XXX Need to fill these in.

=head2 Code Structure
Programming languages have a basic structure.  In C this structure is something
along the lines of: Create a bunch of functions, and or define 
some variables and or structures, then create a main function which is our
entry point into the language.  In general this structure is defined in a 
format called ebnf.  You can find the ebnf for our language here:
src/LPC.cf  We are using this as input to bnfc, if you want to learn more
about the file format do a google search for bnfc.

The structure for our language is a little more complicated than c, we have
to deal with objects and inheritance.  Here is a high level summary, as well
as some basic definitions.

In our language there are 5 types of files, none of them have strict
	extension requirements but we recommend you use them as noted here
	below:
	Include files
		Extension: .h 
		These files can be included in other files with a line similar
		to the following:
			include "myconfig.h";
		They in general are used to contain variables and other
		data structures that you want to share across multiple files.
		In general you want to avoid putting functions in an include
		file and instead use inheritables for that.
		
		Include files will be searched for in the following order:
			The default include path, which is defined in our 
			configuration file, you you can use --include=DIR
			to add a directory to the search path,  you can also
			use the INCLUDE_DIR_LPC environment variable, 
			or specify the full path to the include file.
	inheritables
		Extension: .swl
		These are basically meta objects.  They are not meant to be
		used directly, but are building blocks that other programs can
		use to simplify coding and create a library of reusable
		functions.  You inherit them with a line like this:
		inherit "/std/lib/object.l";

		Inheritable files will be searched for in the following order:
			The default Library path, which is defined in our 
			configuration file, you you can use --lib=DIR
			to add a directory to the search path,  you can also
			use the LIB_DIR_LPC environment variable, 
			or specify the full path to the inheritable file.
	source code
		Extension: .sw

		Source code builds on includes and inheritables and allows
		you to bind them togeather to make useful objects.  If you
		want to convert a source file to compiled code, you use the
		--output=FILENAME option to create a machine code executable.

		When you execute a source file, you can use the standard
		UNIX shell convention #!PATHTOINTERPRETER to execute the file.
		EXAMPLE: #!/usr/local/bin/lpc

		When source code is executed it automatically calls the main()
		function if it exists.

		If you want to reference other objects within this object,
		you will need to clone it and then keep a reference to it, when
		you are done with a clone, you should destroy it to free up
		memory.

	compiled code	XXX Need to look at how dgd seperates this and data 
			files
		Extension: none or .swo   depending on usage.
		This is source code that has been run through are compiler and
		converted to machine code.  If they are standalone executables
		they have no extension, if they are only part of a program they
		have a .o extension.

	data files
		Extension: .dat
		Files that contain configuration information for a 
		cloned object, or provide other data for an object.


=head2 Functions

=head2 A Basic object

=head2 Flow control
